import { useState, useEffect } from 'react';
import Head from 'next/head';

export default function RealPaymentFlowTest() {
  const [step, setStep] = useState(1); // Max 3 steps: 1. Create Order, 2. Initialize Payment, 3. Complete Real Payment
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);
  const [paymentResult, setPaymentResult] = useState(null);
  const [captureStatus, setCaptureStatus] = useState(null);
  const [finalStatus, setFinalStatus] = useState(null);
  const [paymentMethods, setPaymentMethods] = useState([]);
  const [loadingMethods, setLoadingMethods] = useState(false);

  const [formData, setFormData] = useState({
    firstName: 'Real',
    lastName: 'Payment',
    email: 'real.payment@test.cz',
    phone: '+420123456789',
    address: 'Real Payment Street 123',
    city: 'Prague',
    postalCode: '11000',
    country: 'CZ',
    company: 'Real Payment s.r.o.',
    productId: '1',
    productName: 'VPS Basic',
    price: 604,
    cycle: 'm',
    paymentMethod: 'comgate'
  });

  // Load payment methods on component mount and check for payment return
  useEffect(() => {
    loadPaymentMethods();

    // Check if returning from real payment gateway
    const urlParams = new URLSearchParams(window.location.search);
    const paymentStatus = urlParams.get('status');
    const invoiceId = urlParams.get('invoiceId');
    const orderId = urlParams.get('orderId');
    const transactionId = urlParams.get('transactionId');
    const amount = urlParams.get('amount');
    const paymentMethod = urlParams.get('paymentMethod');

    if (paymentStatus && invoiceId) {
      console.log('üîÑ Detected return from REAL payment gateway:', {
        paymentStatus, invoiceId, orderId, transactionId, amount, paymentMethod
      });

      const autoProcessed = urlParams.get('autoProcessed');
      const captureStatus = urlParams.get('captureStatus');
      const currentStatus = urlParams.get('currentStatus');

      // Set up the order data from URL params
      setResult({
        success: true,
        orders: [{
          orderId: orderId || `ORDER-${invoiceId}`,
          invoiceId: invoiceId,
          price: parseFloat(amount) || 604
        }]
      });

      setFormData(prev => ({
        ...prev,
        paymentMethod: paymentMethod || 'comgate',
        price: parseFloat(amount) || 604
      }));

      // Set payment result
      setPaymentResult({
        success: true,
        transactionId: transactionId,
        status: paymentStatus,
        paymentUrl: null,
        redirectRequired: false
      });

      // Move to step 3
      setStep(3);

      // Show return status - if autoProcessed, just display results without calling Capture again
      if (autoProcessed === 'true') {
        console.log('‚úÖ Auto-processed payment detected - checking actual invoice status...');

        // For auto-processed payments, check actual invoice status instead of relying on URL params
        setTimeout(async () => {
          try {
            const statusResponse = await fetch(`http://localhost:3005/api/invoices/${invoiceId}/status`);
            const statusResult = await statusResponse.json();

            if (statusResult.success && statusResult.isPaid) {
              console.log('‚úÖ Auto-processed payment: Invoice is PAID');
              setCaptureStatus({
                success: true,
                message: `üéâ Payment completed and automatically processed by payment gateway!`,
                invoiceId: invoiceId,
                transactionId: transactionId,
                currentStatus: 'Paid',
                timestamp: new Date().toISOString(),
                autoProcessed: true
              });
            } else {
              console.log('‚ö†Ô∏è Auto-processed payment: Invoice is not PAID');
              setCaptureStatus({
                success: false,
                message: `‚ö†Ô∏è Payment was processed but invoice status is unclear.`,
                timestamp: new Date().toISOString(),
                autoProcessed: true
              });
            }
          } catch (error) {
            console.error('Error checking invoice status for auto-processed payment:', error);
            setCaptureStatus({
              success: false,
              message: `‚ö†Ô∏è Unable to verify payment status.`,
              timestamp: new Date().toISOString(),
              autoProcessed: true
            });
          }
        }, 500);

        // Always get final status for auto-processed payments
        setTimeout(async () => {
          try {
            const statusResponse = await fetch(`http://localhost:3005/api/invoices/${invoiceId}/status`);
            const statusResult = await statusResponse.json();

            if (statusResult.success) {
              setFinalStatus({
                success: true,
                invoiceId: statusResult.invoiceId,
                status: statusResult.status,
                isPaid: statusResult.isPaid,
                amount: statusResult.amount,
                datePaid: statusResult.datePaid,
                timestamp: new Date().toISOString()
              });
            }
          } catch (error) {
            console.error('Error getting final status:', error);
          }
        }, 1000);
      } else {
        // For non-auto-processed returns, automatically call Capture Payment for successful payments
        if (paymentStatus === 'success') {
          console.log('üí∞ Automatically calling Capture Payment after successful return...');
          setCaptureStatus({
            success: true,
            message: `‚úÖ Payment successful - automatically capturing...`,
            timestamp: new Date().toISOString(),
            processing: true
          });

          // First check invoice status before calling Capture Payment
          setTimeout(async () => {
            try {
              // Step 1: Check current invoice status
              console.log('üîç Checking invoice status before capture...');
              const statusResponse = await fetch(`http://localhost:3005/api/invoices/${invoiceId}/status`);
              const statusResult = await statusResponse.json();

              if (statusResult.success && statusResult.isPaid) {
                console.log('‚úÖ Invoice is already PAID - skipping capture');
                setCaptureStatus({
                  success: true,
                  message: `üéâ Invoice is already marked as PAID!`,
                  invoiceId: invoiceId,
                  transactionId: transactionId,
                  currentStatus: 'Paid',
                  timestamp: new Date().toISOString(),
                  skippedCapture: true
                });

                // Get final status
                setFinalStatus({
                  success: true,
                  invoiceId: statusResult.invoiceId,
                  status: statusResult.status,
                  isPaid: statusResult.isPaid,
                  amount: statusResult.amount,
                  datePaid: statusResult.datePaid,
                  timestamp: new Date().toISOString()
                });

                return;
              }

              // Step 2: Invoice is not paid yet, proceed with capture
              console.log('üí∞ Invoice not paid yet - proceeding with capture...');
              const captureResponse = await fetch('/api/middleware/capture-payment', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  invoice_id: invoiceId,
                  amount: parseFloat(amount) || 604,
                  module: paymentMethod === 'comgate' ? 'Comgate' : 'BankTransfer',
                  trans_id: transactionId || `REAL-PAYMENT-${invoiceId}`,
                  note: `Real payment captured automatically after successful ${paymentMethod} gateway return`
                })
              });

              const captureResult = await captureResponse.json();

              if (captureResult.success) {
                setCaptureStatus({
                  success: true,
                  message: `üéâ Payment captured successfully!`,
                  invoiceId: invoiceId,
                  transactionId: captureResult.data?.transaction_id,
                  currentStatus: captureResult.data?.current_status,
                  previousStatus: captureResult.data?.previous_status,
                  timestamp: new Date().toISOString(),
                  autoProcessed: false
                });

                // Get final status
                setTimeout(async () => {
                  try {
                    const statusResponse = await fetch(`http://localhost:3005/api/invoices/${invoiceId}/status`);
                    const statusResult = await statusResponse.json();

                    if (statusResult.success) {
                      setFinalStatus({
                        success: true,
                        invoiceId: statusResult.invoiceId,
                        status: statusResult.status,
                        isPaid: statusResult.isPaid,
                        amount: statusResult.amount,
                        datePaid: statusResult.datePaid,
                        timestamp: new Date().toISOString()
                      });
                    }
                  } catch (error) {
                    console.error('Error getting final status:', error);
                  }
                }, 1000);

              } else {
                setCaptureStatus({
                  success: false,
                  message: `‚ö†Ô∏è Payment successful but capture failed: ${captureResult.error}`,
                  error: captureResult.error,
                  timestamp: new Date().toISOString()
                });
              }
            } catch (error) {
              console.error('Error calling Capture Payment:', error);
              setCaptureStatus({
                success: false,
                message: `‚ùå Error calling Capture Payment: ${error.message}`,
                error: error.message,
                timestamp: new Date().toISOString()
              });
            }
          }, 500);

        } else if (paymentStatus === 'cancelled') {
          setCaptureStatus({
            success: false,
            message: `‚ö†Ô∏è Payment was cancelled at the gateway.`,
            timestamp: new Date().toISOString()
          });
        } else {
          setCaptureStatus({
            success: false,
            message: `‚ùå Payment failed or had issues at the gateway.`,
            timestamp: new Date().toISOString()
          });
        }
      }

      // Clean up URL parameters
      window.history.replaceState({}, document.title, window.location.pathname);
    }
  }, []);

  const loadPaymentMethods = async () => {
    try {
      setLoadingMethods(true);
      console.log('üîç Loading payment methods from middleware...');

      const response = await fetch('http://localhost:3005/api/payment-modules');
      const data = await response.json();

      if (data.success && data.modules) {
        setPaymentMethods(data.modules);
        console.log('‚úÖ Payment methods loaded:', data.modules);

        // Set Comgate as default if available
        if (data.modules.length > 0) {
          const comgateMethod = data.modules.find(m => m.method === 'comgate');
          const defaultMethod = comgateMethod ? comgateMethod.method : data.modules[0].method;
          setFormData(prev => ({ ...prev, paymentMethod: defaultMethod }));
          console.log('üéØ Default payment method set:', defaultMethod);
        }
      } else {
        console.error('‚ùå Failed to load payment methods:', data.error);
      }
    } catch (error) {
      console.error('‚ùå Error loading payment methods:', error);
    } finally {
      setLoadingMethods(false);
    }
  };

  const handleInputChange = (field, value) => {
    let updates = { [field]: value };

    // Auto-update product name and price based on product ID
    if (field === 'productId') {
      switch (value) {
        case '1':
          updates.productName = 'VPS Basic';
          updates.price = 604;
          break;
        case '2':
          updates.productName = 'VPS Pro';
          updates.price = 899;
          break;
        case '3':
          updates.productName = 'VPS Premium';
          updates.price = 1299;
          break;
        case '4':
          updates.productName = 'VPS Enterprise';
          updates.price = 1899;
          break;
      }
    }

    setFormData(prev => ({
      ...prev,
      ...updates
    }));
  };

  const createOrder = async () => {
    setLoading(true);
    setError(null);
    try {
      console.log('üöÄ Creating order for real payment flow...');
      
      const response = await fetch('http://localhost:3005/api/orders/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          customer: {
            firstName: formData.firstName,
            lastName: formData.lastName,
            email: formData.email,
            phone: formData.phone,
            address: formData.address,
            city: formData.city,
            postalCode: formData.postalCode,
            country: formData.country,
            company: formData.company
          },
          items: [
            {
              productId: formData.productId,
              name: formData.productName,
              price: parseFloat(formData.price),
              cycle: formData.cycle,
              quantity: 1,
              configOptions: {
                cpu: '2 vCPU',
                ram: '4GB',
                storage: '50GB'
              }
            }
          ],
          affiliate: null,
          paymentMethod: formData.paymentMethod,
          newsletterSubscribe: false,
          type: 'complete'
        })
      });
      
      const data = await response.json();
      if (data.success) {
        setResult(data);
        setStep(2);
        console.log('‚úÖ Order created successfully:', data.orders[0]);
      } else {
        setError(data.error || 'Order creation failed');
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const initializePayment = async () => {
    if (!result?.orders?.[0]) return;

    setLoading(true);
    setError(null);
    try {
      const order = result.orders[0];
      console.log('üîÑ Initializing REAL payment and redirecting to gateway...', order.invoiceId);

      const response = await fetch('http://localhost:3005/api/payments/initialize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          orderId: order.orderId,
          invoiceId: order.invoiceId,
          method: formData.paymentMethod,
          amount: formData.price,
          currency: 'CZK',
          testFlow: false, // This is for REAL payment
          // Custom return URL to come back to this test page
          returnUrl: `${window.location.origin}/real-payment-flow-test?status=success&invoiceId=${order.invoiceId}&orderId=${order.orderId}&amount=${formData.price}&paymentMethod=${formData.paymentMethod}`,
          cancelUrl: `${window.location.origin}/real-payment-flow-test?status=cancelled&invoiceId=${order.invoiceId}&orderId=${order.orderId}&amount=${formData.price}&paymentMethod=${formData.paymentMethod}`,
          pendingUrl: `${window.location.origin}/real-payment-flow-test?status=pending&invoiceId=${order.invoiceId}&orderId=${order.orderId}&amount=${formData.price}&paymentMethod=${formData.paymentMethod}`
        })
      });

      const data = await response.json();
      if (data.success) {
        setPaymentResult(data);
        console.log('‚úÖ Payment initialized for real flow:', data);

        // If payment URL is available, AUTOMATICALLY redirect to real payment gateway
        if (data.paymentUrl && data.redirectRequired) {
          console.log('üöÄ AUTOMATICALLY redirecting to REAL payment gateway:', data.paymentUrl);

          const selectedMethod = paymentMethods.find(m => m.method === formData.paymentMethod);
          const methodName = selectedMethod?.name || formData.paymentMethod.toUpperCase();

          // Show confirmation before redirect
          const confirmRedirect = confirm(
            `Redirect to REAL ${methodName} payment gateway?\n\n` +
            `‚ö†Ô∏è WARNING: This is a REAL payment - you will be charged!\n\n` +
            `Transaction ID: ${data.transactionId}\n` +
            `Amount: ${formData.price} CZK\n` +
            `Method: ${methodName}\n\n` +
            `After completing payment, you will automatically return to this page.\n` +
            `The page will then show the payment status and allow you to capture the payment.\n\n` +
            `Click OK to proceed with REAL payment, Cancel to stay on test page.`
          );

          if (confirmRedirect) {
            // Store transaction ID for return URL update
            console.log('üíæ Storing transaction ID for return:', data.transactionId);

            // Redirect to REAL payment gateway
            window.location.href = data.paymentUrl;
            return; // Don't continue with test flow
          } else {
            setStep(3); // Stay on test page
          }
        } else {
          setStep(3);
        }
      } else {
        setError(data.error || 'Payment initialization failed');
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };



  const styles = {
    container: {
      minHeight: '100vh',
      backgroundColor: '#f8f9fa',
      fontFamily: 'Arial, sans-serif',
      padding: '20px'
    },
    header: {
      backgroundColor: '#007bff',
      color: 'white',
      padding: '20px',
      borderRadius: '8px',
      marginBottom: '20px',
      textAlign: 'center'
    },
    section: {
      backgroundColor: 'white',
      borderRadius: '8px',
      padding: '20px',
      marginBottom: '20px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
    },
    button: {
      padding: '12px 24px',
      border: 'none',
      borderRadius: '4px',
      fontSize: '16px',
      fontWeight: 'bold',
      cursor: 'pointer',
      margin: '5px',
      transition: 'all 0.2s'
    },
    buttonPrimary: {
      backgroundColor: '#007bff',
      color: 'white'
    },
    buttonSuccess: {
      backgroundColor: '#28a745',
      color: 'white'
    },
    buttonWarning: {
      backgroundColor: '#ffc107',
      color: '#212529'
    },
    buttonDisabled: {
      backgroundColor: '#6c757d',
      color: 'white',
      cursor: 'not-allowed'
    },
    input: {
      width: '100%',
      padding: '8px',
      border: '1px solid #ddd',
      borderRadius: '4px',
      fontSize: '14px',
      marginBottom: '10px'
    },
    select: {
      width: '100%',
      padding: '8px',
      border: '1px solid #ddd',
      borderRadius: '4px',
      fontSize: '14px',
      marginBottom: '10px'
    },
    errorBox: {
      backgroundColor: '#f8d7da',
      border: '1px solid #dc3545',
      borderRadius: '8px',
      padding: '15px',
      marginBottom: '20px',
      color: '#721c24'
    },
    successBox: {
      backgroundColor: '#d4edda',
      border: '2px solid #28a745',
      borderRadius: '8px',
      padding: '15px',
      marginBottom: '20px'
    }
  };

  return (
    <div style={styles.container}>
      <Head>
        <title>Real Payment Flow Test - HostBill Integration</title>
      </Head>

      <div style={styles.header}>
        <h1 style={{ margin: '0 0 10px 0' }}>üí≥ Real Payment Flow Test</h1>
        <p style={{ margin: 0, opacity: 0.9 }}>
          Test kompletn√≠ho flow s re√°lnou platebn√≠ br√°nou a Capture Payment
        </p>
      </div>

      {/* Progress Steps */}
      <div style={styles.section}>
        <h2 style={{ color: '#333', marginBottom: '15px' }}>üìã Progress</h2>
        <div>
          <span style={{ color: step >= 1 ? '#28a745' : '#6c757d' }}>
            {step >= 1 ? '‚úÖ' : '‚è≥'} 1. Create Order
          </span>
          {' ‚Üí '}
          <span style={{ color: step >= 2 ? '#28a745' : '#6c757d' }}>
            {step >= 2 ? '‚úÖ' : '‚è≥'} 2. Initialize Real Payment & Auto Capture
          </span>
        </div>
      </div>

      {/* Error Display */}
      {error && (
        <div style={styles.errorBox}>
          <h4 style={{ margin: '0 0 10px 0' }}>‚ùå Error</h4>
          <p style={{ margin: 0 }}>{error}</p>
        </div>
      )}

      {/* Step 1: Create Order */}
      {step === 1 && (
        <div style={styles.section}>
          <h2 style={{ color: '#333', marginBottom: '20px' }}>
            üõí Krok 1: Vytvo≈ôen√≠ objedn√°vky
          </h2>

          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '20px' }}>
            <div>
              <h3>üë§ Z√°kaznick√© √∫daje</h3>
              <input
                style={styles.input}
                placeholder="Jm√©no"
                value={formData.firstName}
                onChange={(e) => handleInputChange('firstName', e.target.value)}
              />
              <input
                style={styles.input}
                placeholder="P≈ô√≠jmen√≠"
                value={formData.lastName}
                onChange={(e) => handleInputChange('lastName', e.target.value)}
              />
              <input
                style={styles.input}
                placeholder="Email"
                value={formData.email}
                onChange={(e) => handleInputChange('email', e.target.value)}
              />
              <input
                style={styles.input}
                placeholder="Telefon"
                value={formData.phone}
                onChange={(e) => handleInputChange('phone', e.target.value)}
              />
            </div>

            <div>
              <h3>üì¶ Produkt a platba</h3>
              <select
                style={styles.select}
                value={formData.productId}
                onChange={(e) => handleInputChange('productId', e.target.value)}
              >
                <option value="1">VPS Basic - 604 CZK</option>
                <option value="2">VPS Pro - 899 CZK</option>
                <option value="3">VPS Premium - 1299 CZK</option>
                <option value="4">VPS Enterprise - 1899 CZK</option>
              </select>

              <select
                style={styles.select}
                value={formData.paymentMethod}
                onChange={(e) => handleInputChange('paymentMethod', e.target.value)}
                disabled={loadingMethods}
              >
                {loadingMethods ? (
                  <option>Loading payment methods...</option>
                ) : (
                  paymentMethods.map(method => (
                    <option key={method.method} value={method.method}>
                      {method.name} ({method.method})
                    </option>
                  ))
                )}
              </select>

              <div style={{ 
                backgroundColor: '#e3f2fd', 
                padding: '10px', 
                borderRadius: '4px', 
                fontSize: '14px',
                marginTop: '10px'
              }}>
                <strong>Cena:</strong> {formData.price} CZK<br/>
                <strong>Platebn√≠ metoda:</strong> {paymentMethods.find(m => m.method === formData.paymentMethod)?.name || formData.paymentMethod}
              </div>
            </div>
          </div>

          <button
            onClick={createOrder}
            disabled={loading}
            style={{
              ...styles.button,
              ...(loading ? styles.buttonDisabled : styles.buttonPrimary),
              marginTop: '20px'
            }}
          >
            {loading ? '‚è≥ Creating Order...' : 'üöÄ 1. Create Order'}
          </button>
        </div>
      )}

      {/* Step 2: Initialize Payment */}
      {step === 2 && result && (
        <div style={styles.section}>
          <h2 style={{ color: '#333', marginBottom: '20px' }}>
            üí≥ Krok 2: Inicializace re√°ln√© platby
          </h2>

          <div style={styles.successBox}>
            <h3 style={{ color: '#155724', margin: '0 0 15px 0' }}>‚úÖ Objedn√°vka vytvo≈ôena</h3>
            <div style={{ fontSize: '14px' }}>
              <div><strong>Order ID:</strong> {result.orders[0].orderId}</div>
              <div><strong>Invoice ID:</strong> {result.orders[0].invoiceId}</div>
              <div><strong>Amount:</strong> {formData.price} CZK</div>
              <div><strong>Payment Method:</strong> {paymentMethods.find(m => m.method === formData.paymentMethod)?.name}</div>
            </div>
          </div>

          <div style={{
            backgroundColor: '#fff3cd',
            border: '1px solid #ffc107',
            borderRadius: '8px',
            padding: '15px',
            marginBottom: '20px'
          }}>
            <h4 style={{ color: '#856404', margin: '0 0 10px 0' }}>‚ö†Ô∏è Re√°ln√° platba</h4>
            <p style={{ margin: 0, color: '#856404' }}>
              Toto inicializuje RE√ÅLNOU platbu p≈ôes {paymentMethods.find(m => m.method === formData.paymentMethod)?.name} br√°nu.
              Po inicializaci budete p≈ôesmƒõrov√°ni na platebn√≠ br√°nu pro dokonƒçen√≠ platby.
            </p>
          </div>

          <button
            onClick={initializePayment}
            disabled={loading}
            style={{
              ...styles.button,
              ...(loading ? styles.buttonDisabled : styles.buttonWarning)
            }}
          >
            {loading ? '‚è≥ Initializing...' : 'üí≥ 2. Initialize Real Payment'}
          </button>
        </div>
      )}



      {/* Capture Status */}
      {captureStatus && (
        <div style={{
          ...styles.successBox,
          backgroundColor: captureStatus.success ? '#d4edda' : '#f8d7da',
          border: `2px solid ${captureStatus.success ? '#28a745' : '#dc3545'}`
        }}>
          <h3 style={{
            color: captureStatus.success ? '#155724' : '#721c24',
            marginBottom: '15px'
          }}>
            {captureStatus.success ?
              (captureStatus.autoProcessed ? 'üéâ Payment Processed Successfully' : 'üí∞ Payment Captured Successfully') :
              (captureStatus.autoProcessed ? '‚ö†Ô∏è Payment Processing Issue' : '‚ùå Payment Capture Failed')
            }
          </h3>
          
          {captureStatus.success ? (
            <div style={{ fontSize: '14px', lineHeight: '1.6' }}>
              <div style={{ marginBottom: '10px' }}>
                <strong>üìã Capture Details:</strong>
              </div>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginBottom: '15px' }}>
                <div><strong>Invoice ID:</strong> {captureStatus.invoiceId}</div>
                <div><strong>Amount:</strong> {captureStatus.amount} CZK</div>
                <div><strong>Transaction ID:</strong> {captureStatus.transactionId}</div>
                <div><strong>Payment Module:</strong> {captureStatus.paymentModule}</div>
                <div><strong>Previous Status:</strong> {captureStatus.previousStatus}</div>
                <div><strong>Current Status:</strong> {captureStatus.currentStatus}</div>
              </div>
              
              {captureStatus.currentStatus === 'Paid' && (
                <div style={{
                  backgroundColor: '#28a745',
                  color: 'white',
                  padding: '10px',
                  borderRadius: '4px',
                  textAlign: 'center',
                  fontWeight: 'bold',
                  marginTop: '10px'
                }}>
                  üéâ Invoice successfully marked as PAID!
                </div>
              )}
              
              <div style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
                <strong>Captured At:</strong> {new Date(captureStatus.capturedAt).toLocaleString('cs-CZ')}
              </div>
            </div>
          ) : (
            <div style={{ fontSize: '14px', color: '#721c24' }}>
              <div><strong>Error:</strong> {captureStatus.error}</div>
              {captureStatus.details && (
                <div><strong>Details:</strong> {captureStatus.details}</div>
              )}
            </div>
          )}
        </div>
      )}

      {/* Final Status */}
      {finalStatus && (
        <div style={{
          ...styles.successBox,
          backgroundColor: finalStatus.success && finalStatus.isPaid ? '#d4edda' : '#fff3cd',
          border: `2px solid ${finalStatus.success && finalStatus.isPaid ? '#28a745' : '#ffc107'}`
        }}>
          <h3 style={{ 
            color: finalStatus.success && finalStatus.isPaid ? '#155724' : '#856404', 
            marginBottom: '15px' 
          }}>
            üìä Final Invoice Status
          </h3>
          
          {finalStatus.success ? (
            <div style={{ fontSize: '14px', lineHeight: '1.6' }}>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginBottom: '15px' }}>
                <div><strong>Invoice ID:</strong> {finalStatus.invoiceId}</div>
                <div><strong>Status:</strong> {finalStatus.status}</div>
                <div><strong>Is Paid:</strong> {finalStatus.isPaid ? 'YES' : 'NO'}</div>
                <div><strong>Amount:</strong> {finalStatus.amount} CZK</div>
                <div><strong>Date Paid:</strong> {finalStatus.datePaid || 'Not paid'}</div>
              </div>
              
              {finalStatus.isPaid ? (
                <div style={{
                  backgroundColor: '#28a745',
                  color: 'white',
                  padding: '15px',
                  borderRadius: '4px',
                  textAlign: 'center',
                  fontWeight: 'bold'
                }}>
                  üéâ SUCCESS: Real Payment Flow Completed Successfully!<br/>
                  Invoice is marked as PAID and ready for provisioning.
                </div>
              ) : (
                <div style={{
                  backgroundColor: '#ffc107',
                  color: '#212529',
                  padding: '15px',
                  borderRadius: '4px',
                  textAlign: 'center',
                  fontWeight: 'bold'
                }}>
                  ‚ö†Ô∏è Invoice is not yet marked as PAID. Please check the payment status.
                </div>
              )}
            </div>
          ) : (
            <div style={{ fontSize: '14px', color: '#721c24' }}>
              <div><strong>Error:</strong> {finalStatus.error}</div>
            </div>
          )}
        </div>
      )}

      {/* Instructions */}
      <div style={{
        backgroundColor: '#f8f9fa',
        border: '1px solid #dee2e6',
        borderRadius: '8px',
        padding: '15px',
        marginTop: '20px'
      }}>
        <h4 style={{ color: '#495057', margin: '0 0 10px 0' }}>üìã How to use Real Payment Flow Test:</h4>
        <ol style={{ margin: 0, paddingLeft: '20px', lineHeight: '1.6' }}>
          <li><strong>Create Order</strong> - Creates order and invoice in HostBill</li>
          <li><strong>Initialize Real Payment</strong> - Sets up REAL payment gateway connection and redirects</li>
          <li><strong>Pay on Gateway</strong> - ACTUALLY PAY on the real payment gateway</li>
          <li><strong>Auto Return & Capture</strong> - Gateway automatically returns and captures payment</li>
          <li><strong>View Final Status</strong> - Shows final invoice status (PAID)</li>
        </ol>
        <div style={{
          margin: '15px 0 0 0',
          fontSize: '14px',
          color: '#dc3545',
          backgroundColor: '#f8d7da',
          padding: '10px',
          borderRadius: '4px',
          border: '1px solid #dc3545'
        }}>
          <strong>‚ö†Ô∏è WARNING:</strong> This test uses REAL payment processing. You will be charged real money!
          Only use this test if you intend to make an actual payment.
        </div>
      </div>
    </div>
  );
}
